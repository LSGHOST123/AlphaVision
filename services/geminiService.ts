import { AIAnalysis, Asset, NewsItem } from "../types";
import { GoogleGenAI, Type } from "@google/genai";
import { MacdResult } from "../utils/technicalAnalysis";

// Initialize Gemini for AI analysis
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });

/**
 * Fetches real-time news for a given asset using Gemini with Google Search grounding.
 * @param assetName The name of the asset.
 * @returns A promise that resolves to an array of NewsItem objects.
 */
export const fetchNewsForAsset = async (assetName: string): Promise<NewsItem[]> => {
  try {
    const prompt = `Encontre 3 notícias recentes e relevantes sobre "${assetName}".`;
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt,
      config: {
        tools: [{ googleSearch: {} }],
      },
    });

    const groundingChunks = response.candidates?.[0]?.groundingMetadata?.groundingChunks;
    if (groundingChunks && groundingChunks.length > 0) {
      return groundingChunks.map((chunk: any) => {
        const url = new URL(chunk.web.uri);
        return {
          title: chunk.web.title,
          url: chunk.web.uri,
          source: url.hostname.replace('www.', ''),
          date: new Date().toLocaleDateString('pt-BR'), // Grounding doesn't provide dates, so we use current.
        };
      });
    }
    return [];
  } catch (error) {
    console.error("Error fetching real-time news with Gemini:", error);
    return []; // Return empty array on error
  }
};


/**
 * Generates an AI analysis for a given asset using the Gemini API.
 * @param asset The financial asset to analyze.
 * @returns An AIAnalysis object generated by the Gemini API.
 */
export const generateAnalysis = async (
    asset: Asset,
    rsi: number | null,
    macd: MacdResult | null,
    smas: { short: number | null, long: number | null }
): Promise<AIAnalysis> => {
    const prices = asset.chartData.map(d => d.price);
    const recentPrices = prices.slice(-10).map(p => p.toFixed(2)).join(', ');

    const prompt = `
      Você é um analista financeiro de IA. Analise o seguinte ativo financeiro e forneça uma recomendação de investimento.
      
      Ativo: ${asset.name} (${asset.symbol})
      Preço Atual: ${asset.price.toFixed(2)} ${asset.baseCurrency}
      Dados de Preços Recentes (últimos 10 dias): ${recentPrices}

      Indicadores Técnicos Atuais:
      - RSI (14 dias): ${rsi ? rsi.toFixed(2) : 'N/A'} (Valores > 70 indicam sobrecompra, < 30 indicam sobrevenda)
      - Médias Móveis Simples (MMS): Curta (10 dias) = ${smas.short ? smas.short.toFixed(2) : 'N/A'}, Longa (20 dias) = ${smas.long ? smas.long.toFixed(2) : 'N/A'} (Cruzamento da curta sobre a longa é sinal de compra)
      - MACD (12,26,9): Linha MACD = ${macd ? macd.MACD.toFixed(2) : 'N/A'}, Linha de Sinal = ${macd ? macd.signal.toFixed(2) : 'N/A'} (Cruzamento da linha MACD sobre a de sinal é sinal de compra)
      
      Com base nesses dados e indicadores, forneça uma análise técnica concisa. Justifique sua recomendação com base nos indicadores.
      Eu preciso de uma resposta em JSON com a seguinte estrutura:
      - recommendation: 'COMPRE', 'VENDA', ou 'MANTENHA'
      - reasoning: Uma breve justificativa técnica (2-3 frases) para a recomendação, mencionando os indicadores.
      - risk: O nível de risco percebido ('BAIXO', 'MÉDIO', 'ALTO'). Considere a volatilidade do ativo. Criptomoedas são 'ALTO'. Ações podem ser 'MÉDIO' ou 'ALTO'. Índices e câmbio são 'BAIXO'.
      - potentialReturn: Uma faixa percentual de retorno potencial (ex: '3% a 7%').
      - probabilities: Um objeto com a probabilidade de alta ('up') e de baixa ('down'), somando 100.
    `;

    try {
      const response = await ai.models.generateContent({
          model: "gemini-2.5-flash",
          contents: prompt,
          config: {
            responseMimeType: "application/json",
            responseSchema: {
              type: Type.OBJECT,
              properties: {
                recommendation: { type: Type.STRING, enum: ['COMPRE', 'VENDA', 'MANTENHA'] },
                reasoning: { type: Type.STRING },
                risk: { type: Type.STRING, enum: ['BAIXO', 'MÉDIO', 'ALTO'] },
                potentialReturn: { type: Type.STRING },
                probabilities: {
                  type: Type.OBJECT,
                  properties: {
                    up: { type: Type.NUMBER },
                    down: { type: Type.NUMBER },
                  },
                   required: ['up', 'down'],
                },
              },
              required: ['recommendation', 'reasoning', 'risk', 'potentialReturn', 'probabilities'],
            },
          },
      });

      const analysisText = response.text.trim();
      const analysis = JSON.parse(analysisText);

      // Basic validation
      if (analysis.recommendation && analysis.reasoning && analysis.probabilities) {
          return analysis as AIAnalysis;
      } else {
          throw new Error("Invalid analysis format from AI");
      }

    } catch (error) {
      console.error("Error generating AI analysis with Gemini:", error);
      // Fallback to a user-friendly error message
      return {
        recommendation: 'MANTENHA',
        reasoning: 'Não foi possível gerar a análise da IA no momento devido a um erro. Por favor, tente novamente mais tarde.',
        risk: 'MÉDIO',
        potentialReturn: 'Indeterminado',
        probabilities: { up: 50, down: 50 },
      };
    }
};